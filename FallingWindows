animations {
    // Uncomment to turn off all animations.
    // off
    // Slow down all animations by this factor. Values below 1 speed them up instead.
    // slowdown 3.0

    // Custom opening animation, reverse falling windows, adapted from https://github.com/YaLTeR
    window-open {
        duration-ms 500
        curve "cubic-bezier" 0.25 1 0.5 1
        custom-shader r"

        vec4 fall_and_rotate(vec3 coords_geo, vec3 size_geo) {
            float progress = (1.0 - niri_clamped_progress);
            progress = progress * progress;
            vec2 coords = (coords_geo.xy - vec2(0.5, 1.0)) * size_geo.xy;
            coords.y -= progress * 1440.0;
            float random = (niri_random_seed - 0.5) / 2.0;
            random = sign(random) - random;
            float max_angle = 0.5 * random;
            float angle = progress * max_angle;
            mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
            coords = rotate * coords;
            coords_geo = vec3(coords / size_geo.xy + vec2(0.5, 1.0), 1.0);
            vec3 coords_tex = niri_geo_to_tex * coords_geo;
            vec4 color = texture2D(niri_tex, coords_tex.st);

            return color;
        }
        vec4 open_color(vec3 coords_geo, vec3 size_geo) {
            return fall_and_rotate(coords_geo, size_geo);
        }"
    }
    // Custom close animation, falling windows, most likely by https://github.com/YaLTeR
    window-close {
        duration-ms 500
        curve "cubic-bezier" 0.25 1 0.5 1
        custom-shader r"

        vec4 fall_and_rotate(vec3 coords_geo, vec3 size_geo) {
            float progress = niri_clamped_progress * niri_clamped_progress;
            vec2 coords = (coords_geo.xy - vec2(0.5, 1.0)) * size_geo.xy;
            coords.y -= progress * 1440.0;
            float random = (niri_random_seed - 0.5) / 2.0;
            random = sign(random) - random;
            float max_angle = 0.5 * random;
            float angle = progress * max_angle;
            mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
            coords = rotate * coords;
            coords_geo = vec3(coords / size_geo.xy + vec2(0.5, 1.0), 1.0);
            vec3 coords_tex = niri_geo_to_tex * coords_geo;
            vec4 color = texture2D(niri_tex, coords_tex.st);

            return color;
        }
        vec4 close_color(vec3 coords_geo, vec3 size_geo) {
            return fall_and_rotate(coords_geo, size_geo);
        }"
    }
}
